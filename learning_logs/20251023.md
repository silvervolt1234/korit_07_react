# REST API 호출
로그인에 성공하더라도 jwt를 세션 스토리지에 저장했을 뿐 getCars()의 결과값은 가져오지 못한다. 기본적으로 Login 컴포넌트에서 얻은 토큰을 frontend상에서 Carlist를 불러오지 못하는 상황이기에 carapi.ts로 getCars() 호출을 하면 얻어온 jwt를 이용해야 한다

그런데 jwtToken 값이 .then에 걸려있기에 일종의 지역 변수. 그러면 Login 컴포넌트를 벗어나선 사용할 수 없다는 의미

sessionStorage에 setItem을 한 이유는 carapi.ts에서 사용하기 위함

그래서 api들에 token을 집어넣고 중복 코드를 리팩터링. 현재 결과적으로 token들을 함수에서 전부 꺼내쓰고 있고 Authorization : 토큰 식으로 반복해서 사용 중

```tsx
import axios from "axios";
import { CarResponse, Car, CarEntity } from "../types";

export const getCars = async (): Promise<CarResponse[]> => {
    const token = sessionStorage.getItem('jwt');  

    // 세견 스토리지 상에 `Bearer `가 포함. 그런데 Postman에서 요청할 땐 `Bearer ` 부분을 빼놓았기에
    // 프론트엔드 상에서 `Bearer `를 제거하고 그걸 기준으로 요청
    const rawToken = token?.replace('Bearer ', '')          
    const response = await axios.get(`${import.meta.env.VITE_API_URL}/api/cars`, {
        headers: { 'Authorization': `${rawToken}`}
    });

    return response.data._embedded.cars;
}

export const deleteCar = async (link: string) : Promise<CarResponse> => {
    // chainging method 활용
    const token = sessionStorage.getItem('jwt')?.replace('Bearer ', '')
    const response = await axios.delete(link, {
        headers: {
        'Authorization': token
    }
    });
    return response.data
}

export const addCar = async(car: Car) : Promise<CarResponse> => {
    const token = sessionStorage.getItem('jwt');
    const rawToken = token?.replace('Bearer ', '');        
    const response = await axios.post(`${import.meta.env.VITE_API_URL}/api/cars`, car, {
        headers: {
            'Content-Type': 'application/json',
            'Authorization' : rawToken
        },
    });

    return response.data;
}

export const updateCar = async (carEntity: CarEntity): Promise<CarResponse> => {
    const token = sessionStorage.getItem('jwt');
    const rawToken = token?.replace('Bearer ', '');  
    const response = await axios.put(carEntity.url, carEntity.car, {
        headers: {
            'Content-Type': 'application/json',
            'Authorization' : rawToken
        },
    });
    return response.data;
}
```
이상은 refactoring 전 부분으로 위의 말처럼 token을 세션 스토리지에서 불러오고 여기서 Bearer 접두사를 제거하는 부분, 그리고 headers 내에 `'Authorization' : rawToken` 부분이 중복되는걸 확인 가능

이 부분에서 중요한 점은 Scope 개념으로 각 함수의 내부에 token을 선언하고 Bearer 접두사를 제거하고 있기에 함수마다 선언 및 초기화

## 중복 코드 리팩토링
```tsx
import axios, { AxiosRequestConfig } from "axios";
import { CarResponse, Car, CarEntity } from "../types";

const getAxiosConfig = () : AxiosRequestConfig => {
    const token = sessionStorage.getItem('jwt')?.replace('Bearer ', '');

    return {
        headers : {
            'Authorization': token,
            'Content-type' : 'application/json'
        },
    };
};

export const getCars = async (): Promise<CarResponse[]> => { 
    const response = await axios.get(`${import.meta.env.VITE_API_URL}/api/cars`, getAxiosConfig());
    return response.data._embedded.cars;
}

export const deleteCar = async (link: string) : Promise<CarResponse> => {
    const response = await axios.delete(link, getAxiosConfig());
    return response.data
}

export const addCar = async(car: Car) : Promise<CarResponse> => {      
    const response = await axios.post(`${import.meta.env.VITE_API_URL}/api/cars`, car, getAxiosConfig());
    return response.data;
}

export const updateCar = async (carEntity: CarEntity): Promise<CarResponse> => {
    const response = await axios.put(carEntity.url, carEntity.car, getAxiosConfig());
    return response.data;
}
```
이상에서 고려할 점은 getAxiosConfig의 return 타입으로 사용된 AxiosRequestConfig

- AxiosRequestConfig : Axios 라이브러리에서 HTTP 요청을 만들 때 사용되는 구성 객체 타입 정의. 즉 Axios를 경유해 요청을 보내기 위해 필요한 모든 옵션을 담는 일종의 interface

- axios.post(), .get ...과 같은 방식으로 사용. 이는 좀 더 가독성을 높이기 위한 방식으로 메서드 별 요청에 해당하는 사항. 이 경우 endpoint 다음 두 번째 argument로 사용

1. 메서드별 요청
```ts
// GET 요청이라고 가정
axios.get('http://localhost:8080/api/cars', {headers:{Authorzation:token}});
```

2. 일반 요청
```ts
axios({
  method: 'get',
  url: 'http://localhost:8080/api/cars',
  headers: {
    'Authorization': token
  }
})
```
이상의 1, 2 과정 중에 return 타입에 객체 형태로 옵션들을 담을 수 있는 것을 AxiosRequestConfig라고 하고 1번 방법을 사용해서 getAxiosConfig() 함수의 정의가 간단한 편에 속함. 2번 방법은 method 키의 value 지정이 복잡

인터셉터(interceptor)에서의 활용 : request interceptor는 요청이 서버로 가기 전 가로채서 구성 수정. 즉 getAxiosConfig() 함수 요청을 하면 처음엔 token이 없는 상태로 DB까지 가게 될뻔했는데 중간에 가로채서 headers를 추가한다는 의미

## Authentication 실패시 오류 메세지를 토스트 메세지로 응용

```tsx
<Snackbar 
  open={open}
  autoHideDuration={3000}
  onClose={() => setOpen(false)}
  message="ID 혹은 비밀번호가 틀렸습니다."
/>
```
라고 설정을 했다묜 setOpen(true)를 호출하는 부분 필요. Login 컴포넌트 중 어떤 동작을 했을 때 toast message가 출력되어야하며 그래서 setOpem(true) 코드를 어디에 삽입해야하는지 고려