# TypeScript로 리액트 앱 만들기
```tsx
import { useState } from 'react'
import './App.css'

function App() {
    const [ name, setName ] = useState('');
    const handleChange = (event : React.ChangeEvent<HTMLInputElement>) => {
      setName(event.target.value)
    }

    const handleSubmit = (event : React.FormEvent<HTMLFormElement>) => {
      event.preventDefault();
      alert(`Hello ${name}`)
    }

  return (
    <>
      <form onSubmit={handleSubmit}>
        <input type="text" value={name} onChange={handleChange}/>
        <input type="submit" value="제출"/>
      </form>
    </>
  )
}

export default App
```

# React RESTFUL API 구현
cardatabase를 기준으로 react 적용 기술들을 jsx / tsx로 구현하고 이를 위해 네트워킹 파트에 fetch 및 axios를 구현. 이는 비동기 코드를 더 깔끔하고 가독성 있게 만드는 Promise 개념에 대해 사전 학습 필요

react-query를 라이브러리를 사용해 실제 작동이 이루어지는 방식 구현

## ts 프로젝트 생성
1. weatherapp - react - jsx 형태로 생성
2. App.jsx를 초기화
3. npm run dev로 빈 브라우저 출력

## Promise
- 비동기 연산을 처리하는 방법으로 전통적인 방법은 연산의 성공 또는 실패에 대한 callback function을 작성하는 것. 예를 들어 GET 요청을 한다고 가정하면 이에 성공시 sucess() 함수를 호출하고 실패시 failure() 함수를 호출
```js
fuction do AsyncCall(sucess, failure) {
  // 어떤 API 호출
  if(SUCCEED) {
    success(resp);
  } else {
    failure(err);
  }

function sucess(response) {
    // 응답을 가지고 작업 수행
  }

function failure(error) {
    // 오류를 처리하는 로직
  }
}
```
이상은 구버전 작성 방식으로 현재의 Promise는 JS에서 비동기 프로그래밍의 기본 요소기에 Promise를 기반으로 코딩

`Promise란 비동기 연산의 결과를 나타내는 JS 객체`

이를 이용시 비동기 호출을 실행할 때 코드가 단순화. Promise가 없던 시절 코드를 일고 유지가 매우 골치아팠는데 여러개의 중첩 callback function이 요구되었기 때문

요청을 전송하는데 이용하는 API 또는 라이브러리가 프로미스를 지원하는 겨우 프로미스를 이용한 비동기 호출 실행 가능
```js
doAscyCall().then(response => 로직);
```
위의 js 함수 정의 부분들 중 doAsycCall()의 내부의 if절 부분이 필요 없어지는 작성 방식. 이러한 호출 부분을 해석하기 위해서는 method의 결과가 return되고 이것이 다음 .then() 메서드를 실행하는 객체가 되는 점을 이해하고 builder 패턴의 chaining method가 익숙하다면 해석 가능

응답이 반환됬을 때, then() 메서드 내부에 callback() 함수가 실행되어 응답을 argument로 받게 된다

의문점은 then() 메서드의 return 자료형

then() 메서드의 return 자료형 : Promise. 그리고 Promise는 세 가지 형태 중 하나로 
1. 대기(Pending) : 초기 상태
2. 이행(Resolved) : 작업 성공
3. 거부(Rejected) : 작업 실패

이하의 예시는 프로미스를 단순화시킨 형태로 setTimeout을 활용해 비동기 연산을 시뮬레이션
```js
const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Hello');
  }, 500);
})
```
1. JS에서도 생성자를 통한 객체 생성이 가능. `const myPromise = new Promise((resolve, reject) => {`에서 myPromise라는 객체를 생성했다고 볼 수 있다
2. 해당 myPromise 객체는 resolve 매개변수와 reject 매개변수를 가진다
3. 프로미스 객체가 생성될 때 타이머가 실해도니느 동안 프로미스는 대기 상태. 그리고 500 밀리초가 지나면 'Hello'라는 값으로 resolve 함수가 호출되고 프로미스는 이행 상태로 변동. 오류가 방생시 거부 상태로 전환. 현재는 거부 처리 로직 없음

그리고 이상에서 배웠던 .then() 메서드를 통해 인스턴스를 연결해 다수의 비동기 작업을 순차적으로 진행 가능
```js
doAsyncCall()
.then(response => 전체 응답 결과가 나온걸 가지고 비지니스 로직 수행)
.then(data => response를 가공한 결과값을 매개변수 data로 이름 붙이고 추가 비지니스 로직 수행)
```

그리고 rejected된 상태에서 오류처리 추가 가능
```js
doAsyncCall()
.then(response => 전체 응답 결과가 나온걸 가지고 비지니스 로직 수행)
.then(data => response를 가공한 결과값을 매개변수 data로 이름 붙이고 추가 비지니스 로직 수행)
.catch(error  => console.log(error));
```

그러면 Java의 예외처리방법처럼 doAscyCall()과 두 개의 .then() 메서드들 중 어디에서라도 오류/예외가 발생시 catch로 넘어가며 개발자는 콘솔에 출력된 error로 감지하고 수정

## asyc / await
비동기 호출을 처리하는 더 최신 방식은 ECMAScript2017에 도입된 async/await을 이용하는 방식으로 이는 Promise에 대한 개녀믈 알고 있다는 전제 하에 사용하는것을 권장. await 표현식을 포합할 수 있는 async() 함수 정의가 요구됨
```jsx
const doAsyncCall = async () => {
  const response = await fetch('http://someapi.com');
  const data = await response.json();
  // 그리고 data를 가지고 로직 수행하는 부분을 정의
}
```
fetch() 함수가 나오는데 이것의 return 값도 Promise. 단 async / await을 도입하면 .then()을 쓰는게 아닌 await 키워드를 사용해야 함

그리고 오류 처리를 위해서 마찬가지고 async / await에 try-catch 문을 사용 가능
```js
const doAsycCall = async () => {
  try {
    const response = fetch('http://someapi.com');
    const data = await response.json();
    // data를 가지고 추가 비지니스 로직 정의
  }
  catch {
    console.log(error);
  }
}
```
이상이 전반적인 Promise의 정의와 사용 최근 사례. 이를 이용시 React 앱에서 request 작업에 사용하는 fetchAPI에 대해 학습 준비 완료

## fetchAPI를 이용
JS상의 fetch API 개념은 기존의 XMLHttpRequest 혹은 jQuery Ajax API와 유사한데 fetchAPI의 장점은 Promise를 지원. 그리고 react 내장 API라서 추가적인 설치가 필요 없다

fetchAPI는 위의 fetch() 메서드를 제공. 웹 요청의 겨웅 argument는 서비스의 URL이 되고 그래서 처음으로 GET 요청을 react에서 하는 예시를 작성
```jsx
fetch('http://someapi.com')
.then(response => response.json())
.then(data => console.log(data))
.catch(error => console.log(error));
```
fetch() 메서드는 response가 포함된 프로미스를 return하는데 이를 .json을 통해 추출하고 이 메서드 역시 프로미스를 반환(위의 then 메서드의 결과값 사례)

이상의 의사 코드에서 `.then(response => response.json())`에서 전달되는 response는 요청이 성공했는지 확인하는데 이용하는 ok 및 status 속성을 포함하는 객체. 응답이 2xx 형식이라면 ok 값 속성은 true로 return

```jsx
fetch('http://someapi.com') // 성공적으로 fetch가 이루어졌다면 response가 결과값으로 나오고
.then(response => {   // 그 response를 가지고 연산을 하는 의미
  if (respone.ok) {
    // 요청 성공 -> 상태 2xx
  }
  else {
    // 문제 발생 -> 오류 응답(401, 404, 500 etc)
  }
})
.then(data => console.log(data))
.catch(error => console.log(error));
```

POST와 같은 다른 HTTP 메서드를 이용하려면 fetch() 메서드의 두 번째 argument에 해당 메서드를 정의. 두 번째 argument는 여러 요청 설정을 정의가능한 객체
```jsx
fetch('http://someapi.com', { method: 'POST'})
.then(response => response.json)
.then(data => console.log(data))
.catch(error => console.log(error));
```

특정 자격이 있거나 특정 형식으로 headers를 추가할 필요가 존재하는데 fetch()의 두번째 argument인 객체에 key-value properties를 추가해 해결 가능
```jsx
fetch('http://someapi.com',
  { 
    method: 'POST',
    headers: {'Content-Type': 'application/json'}
  })
.then(response => response.json)
.then(data => console.log(data))
.catch(error => console.log(error));
```

요청 본문 내에 JSON으로 인코딩된 데이터를 보내는 경우도 존재하는데 

```jsx
fetch('http://someapi.com',
  {
    method: 'POST'
    headers: {'Content-Type': 'application/json'}
  }
)
```

유일한 요청 수행방식은 아니고 다수의 경우 axios라는 외부 라이브러리 사용

## axios 라이브러리 이용
axios는 fetchAPI처럼 네트워크 호출과 관련된 라이브러리. 즉, POST / GET / PUT / DELELTE 등과 연관

- 여기에 특정 라이브러리르 사용하게 되면 추가 설치 필요
- npm install axios

axios 라이브러리에는 JSON 데이터의 자동변환과 같은 이점이 있는데 그래서 fetch()에 response.json() 메서드를 호출한것과 같은 과정이 필요 x

```jsx
axios.get('http://someapi.com')
.then(response => console.log(response))  // fetch API를 쓰면 then절 하나 감소
.catch(error => console.log(error));
```

POST 요청을 할 때는 axios.post()를 사용
```jsx
axios.post('http://someapi.com', {객체})
.then(response => console.log(response))
.catch(error => console.log(error));
```

axios() 함수를 이용시 method / headers / data / url 등의 세부 정보를 지정하는 객체 전달 가능

```jsx
const response = await axios({
  method: 'POST',
  url: 'https://myapi.com/api/cars',
  headers: {
    'Content-Type': 'application/json'
  },
  data: {brand : '현대', model: 'GV80'}
})
```
그렇기에 이상의 예시는 https://myapi.com/api/cars 엔드 포인트로 POST 요청을 보내는데 요청 본문에 객체가 포함되고 Axios가 자동으로 문자열화(stringify)

## weatherapp
### OpenWeather API 도입
http://openweathermap.org

REST API를 이용하는 경우 응답을 검사해 JSON 데이터의 포맷을 확인. 즉 날씨 정보를 Openweather API를 활용

https://api.openweathermap.org/data/2.5/weather?q=Busan&units=Metric&APIkey=444353129dd297608ab43143b9cba9c5

http://openweathermap.org/img/wn/04d@2x.png
-> 04d가 icon key의 value로 잡혀있고 img를 부르기 위해 @2x.png 필요

```jsx
import { useEffect, useState } from 'react'
import './App.css'

function App() {
  const [ weather, setWeather ] = useState({
    temp: '',
    desc: '',
    icon: ''
  });
  useEffect(() => {
    fetch('https://api.openweathermap.org/data/2.5/weather?q=Busan&units=Metric&APIkey=444353129dd297608ab43143b9cba9c5')
    .then(response => response.json())
    .then(result => {
      setWeather({
        temp: result.main.temp,
        desc: result.weather[0].description,
        icon: result.weather[0].icon
      })
    })
    .catch(error => console.log(error))
  }, []);

  if(weather.icon) {
    return (
      <>
        <p>기온 : {weather.temp}</p>
        <p>설명 : {weather.desc}</p>
        <img src={`http://openweathermap.org/img/wn/${weather.icon}@2x.png`} alt="날씨 아이콘" />
      </>
    );
  } else {
    return <div>Loading ....</div>
  }
}

export default App
```
이상의 코드에서 유념해야할 부분은
1. useState()의 초기값으로 JS 객체 형태를 넣었다는 점 -> user 객체 형태로 firstName / lastName / email을 통해 작성
  - 번거로울시 각각의 상태를 선언
2. useEffect()의 argument 분석
  - 1st argument는 callback function
  - 2nd argument는 어느 시점에 리렌더링 할까를 통제. []의 의미 학습 필요
  - callback function의 내부 로직은 fetchAPI 활용
  - fetchAPI를 이해하기 위해서는 Promise 개념에 대한 선행 요구
3. useEffect()가 최초 렌더링시 호출이 되고 그 결과 callback function이 호출되면 weather라는 상태 업데이트
  - 이를 확인하기 위해 브라우저에서 개발자도구로 Components에서 state 확인 가능
  - 실패시 Network 탭에서 200 OK가 아니라 오류 메세지가 뜨거나 작성한 console.log(error로 콘솔에 오류 메세지 출력)
4. 상태가 업데이트됬음을 확인하면 이를 브라우저에 표시하기 위해 return 작성
  - icon이 img 파일이기에 loading 시간이 길거라고 판단, 그래서 icon의 유무에 따라 조건문 작성을 통해 return 부분 표시

### Github API 도입
1. githubapp 프로젝트 생성
2. App.tsx 초기화
3. npm run dev로 빈화면 출력

키워드로 리포지토리를 가져오는 Github API를 사용. 사용자가 input 태그에 키워드를 입력하고 클릭하면 해당 키워드가 포함된 리포지토리를 가져오는 형태. 이상의 과정에서 axios를 활용해 axios.get()

```tsx
type MyDataType = {
  id: number,
  name: string
}

axios.get<MyDataType>(apiUrl)
.then(response => console.log(response.data))
.catch(error => console.log(error));
```
에상 데이터 타입에 없는 일부 field에 접근하려면 개발 단계 초기에 오류 포착 가능. 이 시점에서 타입스크리브는 자파스크립트로 컴파일링되고 모든 타입 정보가 제거된다. 따라서 타입스크립트는 런타임 작동에 직접 영향을 끼치지 않고 REST API가 예상과 다른 타입의 데이터를 반환하는 경우 타입스크립트는 런타임 오류로 포착 X

TS의 개념을 생각할 때 JavaScript보다 작은 집합이나 혹은 교집합으로 볼 것이 아닌 JavaScript로 컴파일링되기 전에 오류를 포착할 수 있는 filter 역할로 이해

https://api.github.com/search/repositories?q={KEYWORD}

`q=` 는 query를 의미. `=` 다음에 검색하는 내용의 키워드를 넣으면 결과값을 GET 요청으로 가져오기에 input 입력 값을 {KEYWORD}에 대입

이상의 결과값에 들어가면 JSON 데이터가 나오는데, 그 중 items 키를 확인시 배열로 이루어져있는걸 확인 가능

이 개별 repository에서 full_name 값과 html_url 값을 가져오고 그 결과값을 map() 함수를 이용해서 값을 표의 row로 변환. 그 때 key prop을 집어넣어야하는데 id가 고유값이라 id를 사용

그리고 openweatherapp와의 차이점이 존재하는데 useEffect()의 훅 함수 내부에서 axios.get()를 호출 불가능. 이는 컴포넌트가 최초 렌더링 되는 시점에서 q={KEYWORD}에 해당하는 값이 없기에

그래서 사용자 input창에 대한 상태와 JSON 응답 데이터에 대한 상태를 생성. 즉 input창에 값을 입력하면 그 값을 가지고 api에 GET 요청을 날리고 그 결과값을 JSON 응답데이터 상태에 저장되는 순서(weather를 저장한 것처럼)

그런데 전체 JSON 데이터가 배열이기에 field값 id / html_url / full_name이 필요해서 JSON에서 확인

```tsx
import { useState } from 'react'
import axios from 'axios'
import './App.css'

type Repository = {
  id: number;
  full_name: string;
  html_url: string;
  username: string;
}

function App() {
  const [ keyword, setKeyword ] = useState('');
  const [ repodata, setRepodata ] = useState<Repository[]>([]);

  const handleClick = () => {
    axios.get<{items : Repository[]}>(`https://api.github.com/search/repositories?q=${keyword}`)
    .then(response => setRepodata(response.data.items))
    .catch(error => console.log(error))
  }

  return (
    <>
      <input type="text" onChange={e => setKeyword(e.target.value)} value={keyword}/>
      <button onClick={handleClick}>Search</button>
      {repodata.length === 0 ? (
        <p>No data available</p>
      ) : (
        <table>
          <tbody>
            {repodata.map(repo => 
              <tr key={repo.id}>
                <td>{repo.full_name}</td>
                <td>
                  <a href={repo.html_url}>{repo.html_url}</a>
                </td>
              </tr>
            )

            }
          </tbody>
        </table>
      )}
    </>
  )
}

export default App
```

github API가 요청횟수 제한이 있어서 1분에 10회씩만 요청 가능. 한도가 넘어가면 1분 뒤에 테스트 가능

## React Query 라이브러리 이용
React query -> tanstack Query 라고 알려져 있는데 데이터캐싱 및 성능 최적화 관련

React Query 활용 react 앱에서 데이터를 가져오는 방법을 쓰는데 github REST API에서 리포지터리 사용

gitapi -> react -> jsx

npm install @tanstack/react-query@4
npm install axios
npm install
npm run dev
App.jsx 초기회

git add . 
git commit -m "feat : gitapi app create"
git push

- 데이터 캐싱이란?
  - 애플리케이션 성능 최적화의 핵심 개념 중 하나로 네트워크 요청이나 계산 비용이 큰 작업의 결과를 한번 저장해두고(캐시(cache)) 이후 동일 요청이 들어올때까지 저장된 결과를 빠르게 재사용함으로서 응답 시간(latency)을 단축하고 서버 부하를 줄이는 기법

  - 캐시(cache) : 임시 저장소(메모리, 디스크, 브라우저 스토리지 등)에 데이터를 저장해두는 공간
    - 데이터 요청 전 : 애플리케이션은 캐시에 해당 키(URL/쿼리 매개변수)에 대응하는 데이터가 있는지 확인(cache lookup)
    - cache hit : 캐시 데이터가 있고 그것이 유효하다면 저장된 값을 즉시 반환
    - cache miss : 캐시에 데이터가 없거나 만료되었으면 원본(원격 API / DB)에 요청(fetch) -> 데이터를 받아외서 캐시에 저장하고 client에 반환

```tsx
import './App.css'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

const queryClient = new QueryClient();

function App() {

  return (
    <>
      <QueryClientProvider client={queryClient}>
      
      </QueryClientProvider>
    </>
  )
}

export default App
```
위 코드는 React Query를 사용하기 위한 기초 단계로 React Query는 데이터 캐싱을 처리하는 QueryClinetProvider와 QueryClient 컴포넌트를 제공. 이 컴포넌트를 App Component로 가져오는데 QueryClient 객체 생성 후 App Component에서 QueryClientProvider를 렌더링

그리고 React Query는 네트워크 요청을 호출하는데 이용되는 useQuery 훅 함수를 제공

- 형식 :
```jsx
const query = useQuery({ queryKey: ['repositories'], queryFn: getRepositories})
```
- queryKey : 쿼리를 고유한 키로 데이터의 캐싱과 다시 가져오기에 사용
- queryFn : 데이터를 가져오는 함수이며 프로미스 반환 필수(axios나 fetch API 관련)

useQuery 훅이 반환하는 query 객체에는 쿼리 상태와 같은 중요 속성 포함

```jsx
const { isLoading, isError, isSucess } = useQuery({queryKey: ['repositories'], queryFn : getRepositories})
```
가능한 상태 값은 다음 형식으로
- isLoading : 데이터를 아직 이용할 수 없다
- isError : 쿼리가 오류로 종료
- isSucess : 쿼리가 성공적으로 종료되고 쿼리 데이터 이용 가능

query 객체의 데이터 속성에는 응답이 반환하는 데이터 포함

그래서 이상의 useQuery() 훅을 활용해 Github 예제의 reposiotry 정보를 가져오기위해 Repositories.jsx 컴포넌트 생성 후 초기화

```jsx
// Repositories
import { useQuery } from "@tanstack/react-query";
import axios from "axios";

function Repositories() {
  const getGerepositories = async () => {
    const response = await axios.get('https://api.github.com/search/repositories?q=korit_07');
    return response.data.items;
  }

  const { isLoading, isError, data } = useQuery({
    queryKey: ['repositories'],
    queryFn: getGerepositories
  })

  if(isLoading) {
    return <h1>Loading ...</h1>
  }

  if(isError) {
    return <h1>오류가 발생했습니다...</h1>
  } 
  else {
    return (
      <table>
        <tbody>
          {
            data.map(repo => 
              <tr key={repo.id}>
                <td>{repo.full_name}</td>
                <td>
                  <a href={repo.html_url}>{repo.html_url}</a>
                </td>
              </tr>
            )
          }
        </tbody>
      </table>
    )
  }
}

export default Repositories
```
이상을 처리하고 App.jsx에 Repositories 컴포넌트를 QueryClientProvider 컴포넌트 내에 집어넣으면 전의 githubapp과 동일한 기능을 구현

출력된 리포지토리들은 리액트 쿼리 라이브러리를 이용해 가져왔고 또한 내장된 기능을 이용해 요청 상태를 isLoading / isError / data의 형태로 처리했고 리액트 쿼리가 데이터 관리와 캐싱을 처리하기에 응답 데이터를 추가로 저장하기 위한 상태의 선언이 필요 x

그런데 웹에서 탭을 바꾸다보면 브라우저가 재포커스가 되는데 리액트 쿼리에 의해 다시 불러오기가 실행(검색결과가 적을수록 빠름). 또한 github api 정책으로 1분에 10번 이상 발생시 에러 발생

그렇기에 useQuery내에 staleTime이라는 키가 존재하는데 이는 데이터가 최신으로 유지되는 시간을 규정. 기본적으로 0으로 잡혀있어서 재포커스때마다 새로고침 발생
```jsx
  const { isLoading, isError, data } = useQuery({
    queryKey: ['repositories'],
    queryFn: getGerepositories,
    staleTime: 60 * 1000, // 1분을 의미
    cacheTime: 60 * 5000
  })
```
그리고 cacheTime이라는 속성은 비활성상태인 쿼리들이 garbage collection 대상이 되는 타이밍을 의미. default로는 5분으로 설정

여태까지 type으로 정의돤 코드들은 백엔드로 들어가면 record나 dto형태로 전달이 된다고 이해