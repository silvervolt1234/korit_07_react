# Props Drilling
ContextAPI / Recoil /Zustand - Props Drilling을 해결하기 위한 방법

## React Form 처리
- HTML / CSS 학습 때 form 처리와 관련된 부분을 다뤘는데 React에서는 차이 존재. HTML 양식은 제출되면(submit이 이루어지면) 다음 페이지로 이동하는데 React는 제츨 후 폼 데이터에 접근할 수 있는 JS 함수를 호출하고 다음 페이지로의 이동을 방지하는 경우 존재(SPA이기에). .preventDefault()를 이용해 제출 자체를 피할 수 있다

1. MyForm2.jsx 생성
2. App.jsx에 MyForm2만 배치
3. input 하나와 button 하나가 있는 최소한의 폼을 생성하고 입력한 field의 값을 가져오기 위한 onChange 이벤트 핸들러 생성
4. useState() 훅을 사용해 text라는 상태 변수를 생성하고 input 필드의 값이 변경되면 새 값이 상태에 갱신되게 작성
5. MyForm 컴포넌트는 폼 데이터가 리액터에 의해 처리되기에 제어 컴포넌트라고 불리고 제어되지 않는 컴포넌트에서 폼 데이터는 DOM에 의해 처리. `setText(event.target.value);` 문을 통해 input field에서 값을 가져와 상태에 저장하고 입력한 값을 alert으로 출력

#### MyForm2
```jsx
import { useState } from "react"

function MyForm2() {
  const [ text, setText ] = useState("");

  // input field에 입력한것을 submit할시 지울 수 있는 함수
  const handleChange = (event) => {
    setText(event.target.value)
    console.log(text);
  }

  const handleSubmit = (event) => {
    alert(`'${text}'라고 입력하셨습니다.`)
    event.preventDefault();
  }

  return(
    <>
      <form onSubmit={handleSubmit}>
        <input type="text" onChange={handleChange} value={text}/>
        <br />
        <br />
        <input type="submit" value="클릭하세요" />
      </form>
    </>
  )
}

export default MyForm2
```
상태가 업데이트 된다고 매번 리렌더링이 일어나는건 아니고 상태의 변화를 감지해 리렌더링을 일으키는 Hook은 useEffect()

## Reac Developer Tools 확인법
f12 -> Components(확장 프로그램 설치 필요)에서 현재 작성한 코드들의 Hook들 확인 가능. MyForm2를 기준으로 text라는 상태 하나 분이기에

~~~
hooks
1. State : "안녕하세요"
~~~

를 확인 가능하다.

다수의 상태를 확인하는 부분을 체크
1. MyForm3.jsx 생성 후 초기화
2. App.jsx에 MyForm2 위에 import

그런데 todolist로 하나의 input으로 작성해서 대부분의 입력 form에는 입력 field가 복수로 구성. 그러면 각각의 상태를 선언하는 법도 있지만 객체를 이용해 처리하는 방법 역시 존재

#### MyForm3
```jsx
import { useState } from "react"

function MyForm3() {
  const [ user, setUser ] = useState({
    firstName: "",
    lastName: "",
    email: "",
  })

  // form에서 쓸거라 handleSubmit부터 작성
  const handleSubmit = (event) => {
    alert(`Hello, ${user.firstName} ${user.lastName}`);
    event.preventDefault();
  }

  // form 태그를 썻고 내부에 input으로 입력받을거니 onChange를 작성
  // 그런데 여러개의 input 태그 내에 onChange={event => setUser(event.target.value)}를 field 개수대로는 할 필요는 없기에
  const handleChange = (event) => {
    setUser({...user, [event.target.name]: event.target.value })
  }

  return(
    <>
      <form onSubmit={handleSubmit}>
        <label>First Name : </label>
        <input type="text" name="firstName" onChange={handleChange} value={user.firstName}/>
        <br />
        <label>Last Name : </label>
        <input type="text" name="lastName" onChange={handleChange} value={user.lastName}/>
        <br />
        <label>email : </label>
        <input type="text" name="email" onChange={handleChange} value={user.email}/>
        <br />
        <input type="submit" value="클릭하세요" />
      </form>
    </>
  )
}

export default MyForm3
```

JS 객체에서 특정 value를 참조하는 방법
1. 객체명.key
  - console.log(person.firstName);
2. 객체명.['키']
  - console.log(person['firstName']);

### 응용 예제
1. Myform4.jsx를 생성
2. App3.jsx에 기존 내용을 복사하고 App.jsx에 MyForm4만 import
3. 상태를 각각 선언하고 MyForm3와 동일한 기능이 가능하게 코드 작성
  - user 상태가 아니라 firstName / lastName / email을 별개로 선언하고 코드 작성
  - 이상의 경우 onChange에 대한 부분에 변화 발생 가능


#### MyForm4
```jsx
import { useState } from "react"

function MyForm4() {
    const [ firstName, setFirstName ] = useState("")
    const [ lastName, setLastName ] = useState("")
    const [ email, setEmail ] = useState("")

    // 실제 주 역할은 preventDefault
    const handleSubmit = (event) => {
      alert(`Hello, ${firstName}${lastName}`);
      event.preventDefault();
    }

  return( 
    <>
      <form onSubmit={handleSubmit}>
        <label>First Name : </label>
        <input type="text" onChange={e => setFirstName(e.target.value)}/>
        <br />
        <label>Last Name : </label>
        <input type="text" onChange={e => setLastName(e.target.value)}/>
        <br />
        <label>email : </label>
        <input type="email" onChange={e => setEmail(e.target.value)}/>
        <br />
        <input type="submit" value="클릭하세요" />
      </form>
    </>
  )
}

export default MyForm4
```

# TypeScript
- TypeScript는 MS에서 개발한 타입 시스템을 제공하는 JS 상위 집합에 해당. 최근에 인기가 늘어나는 중이고 22년 기준 가장 빠르게 성장하는 프로그래밍 언어로 선정됨

- 특징
1. 변수, 함수, 클래스에 대한 자료형을 정의 할 수 있고 이를 통해 개발 프로세스 초기에 오류 포착이 가능
2. 앱의 확장성을 향상시킬 수 있고 코드를 더 쉽게 유지 관리 용이
3. 코드 가독성이 향상되고 코드 자체 문서화가 쉬워짐

타입스크립트 작성용 웹 IDE 사이트 : https://www.typescriptlang.org/play

## 공통 타입
- TS는 변수를 초기화할 때 변수의 타입을 자동으로 정의하는데 이를 타입추론이라고 호칭
```ts
let message ='안녕하세요';      // string 자료형라고 ts가 추론
message = 1;        // Type 'number' is not assignable to type 'string'.
```
message에 string 값을 대입했을 때 ts는 해당 변수의 자료형이 string이라고 알아서 타입 추론. 그런데 다음 줄에서 message 변수에 number 자료형을 대입하니 오류 메세지가 발생(JS에서는 무관)

TS의 기본 타입은 JS와 동일
1. string : 문자열
2. number : 숫자
3. bool : boolean

그런데 TS가 매번 암시적으로 타입 추론을 하게하는게 아니라 명시적 타입 설정을 하는것도 가능

- 명시적 타입 설정 방법
```ts
let email: string;
email = 3;      // Type 'number' is not assignable to type 'string'.
// 이상의 주목점은 email이 number 자료형으로 초기화가 됬음에도 오류가 발생
let email: string;
let age: number;
let isActive : boolean;

email = 'a@test.com'
age = 1;
// 변수의 자료형 확인
console.log(typeof email);   // 결과값 : "string" 
console.log(typeof age === 'string');   // 결과값 : false 
```
그런데 변수의 타입을 모르는 경우도 존재. ex) 외부 소스로부터 값을 받아 올때

```ts
let externalValue: unknown;
```
* 참조 : TS에서는 any라는 자료형 존재. any 타입을 이용해 변수를 정의하는 경우 TS가 해당 변수에 대해 타입 검사 또는 추론 X(기존의 JS처럼 사용 가능). 그러나 TS를 사용하지 않는것과 차이가 없어서 any 사용은 자제

- 배열 Array : JS에서 동일한 방식으로 선언할 수 있기는 하나 배열의 element들의 자료형을 정의
```ts
let arrayOfNums: number[] = [1,2,3,4,5];
let animals: string[] = ['Dog', 'Cat', 'Tiger'];

// 제네릭 타입을 사용하는 방법
let arrayOfNums2: Array<number> = [9,8,7,6];
let animals2: Array<string> = ['개', '고양이', '호랑이'];
```
- 또한 객체 object에서도 각각의 property에 대한 타입 추론을 알아서 실행
```ts
const student = {
  id: 1,
  name: '김일',
  email: 'kim1@test.com'
}
```
라고 했을 때 student.id의 자료형은 number, student.name / student.email의 자료형은 string이라고 알아서 추론

그런데 이 부분도 미리 통제를 하려면 interface / type 키워드를 활용해 객체 내부의 property의 자료형을 명시 가능

```ts
// interface 이용 사례
interface Student {
    id: number;
    name: string;
    email: string;
};
// 또한 JS처럼 생겨서 (,)로 오류 자주 발생

// type 이용 사례
type Student2 = {
    id: number;
    name: string;
    email: string;
};
// 이상과 같이 Student에 대한 속성에 대한 자료형이 있다고 가정하면 이를 모아둔 Student를 자료형으로 사용 가능

const myStudent: Student = {
    id: 1,
    name: '김일',
    email: 'kim1@test.com'
};
// id : '1'로 쓰면 error 발생
```

그리고 Java에서의 와일드 카드에 해당하는 `?`도 존재. 선택적 속성을 정의할 수 있는데 이는 일종의 생성자 부분과 관련이 있다.

```ts
type Student2 = {
    id: number;
    name: string;
    email?: string;
};

const myStudent: Student2 = {
    id: 1,
    name: '김일',
};

console.log(myStudent.email)    // 결과값: undefined 
```
- 선택적 체이닝 연산자(?.)를 이용하면 오류를 일으키지 않고 null이거나 undefined일 수 있는 객체 속성 및 메서드에 안전하게 접근 가능

```ts
// type 정의
type Person = {
  name: string;
  email: string;
  address?: {
    street: string;
    city: string;
  }
}
// 객체 생성
const person: Person = {
    name: '김이',
    email: 'kim2@test.com'
}

console.log(person);          

// 오류가 생기는 부분
// console.log(person.address.street)   // [ERR]: "Executed JavaScript Failed:"   // [ERR]: Cannot read properties of undefined (reading 'street') 

// 선택적 체이닝으로 오류 발생 억제
console.log(person.address?.street)     // [LOG]: undefined 
```
이상의 결과값으로는 undefined가 출력되고 오류 발생 없음

이상까지의 상황에서 TS를 적용했을 때의 이점은 기본적으로 JS 상에서 실행을 시키고 나서야 오류 유무를 확인 할 수 있는 반면 TS 상에서는 개발 단계엇 (=테스트/실전 데이터 입력 이전 단계에서) 예측 가능한 오류를 발생시지 않을 수 있다는 점

- 연산자를 이용한 서로 다른 타입을 병렬로 명시하는 방법
```ts
type InputType = string | number;
// 정의한 타입 이용
let username: InputType = 'Hello';
let age: InputType = 12;
```

```ts
type Fuel = 'disel' | 'gasoline' | 'electric';
type NoOfGears = 5 | 6 | 7;

type Car = {
    brand: string;
    fuel: Fuel;
    gears: NoOfGears;
};

const car1: Car = {
    brand: '기아',
    fuel: 'disel',   // 오타가 나거나 Fuel 내에 있는 string data를 벗어나면
    gears: 5         // 5,6,7가 아닌 다른 숫자가 들어가도 오류
}
```
이상의 예시는 연산자를 이용하여 서로 다른 타입을 처리하는 타입인 유니언 타입(Union Type)을 만드는 것이 가능

첫 번째 예시의 경우에는 string이거나 number일 수 있는 InputType이라는 유니언 타입을 생성하고 두 번째는 특정 string data(disel, gasoline, electric)거나 특정 number data(5,6,7)만을 가질 수 있는 유니언 타입인 Fuel / NoOfGears를 생성

일종의 사용자 정의 type이라고 볼 수 있다. Java에서 class 정의와 유사

## 함수
```ts
function sayHello(name: string) {
  console.log('hello' + name);
}

// name이 꼭 string이여야만 할 필요는 없고 숫자를 넣으려면
function sayHello(name: string | number) {    // or 사용
  console.log('hello ' + name);
}

sayHello(1);
sayHello('김일');
```
예시)
```ts
function checkId(id: string | number) {
  if(typeof id === 'string') {
    // id가 string일 때의 특정 로직 수행
  } else {
    // id가 number일 때의 특정 로직 수행
  }
}
```
이상의 경우 매개변수의 자료형을 고정시키거나 혹은 복수의 자료형 중에 하나를 선택할 수 있게 통제하는 방안을 학습

이하는 return 타입에 대한 자료형 통제 부분
```ts
function calsSum(x: number, y: number): number {
  return x + y;
}
```
여기까지가 TS의 기초 파트

## TypeScript in React
### 상태와 프롭
- 리액트에서는 컴포넌트 프롭의 타입을 정의. 컴포넌트의 프롭이 JS 객체라고 학습을 했었는데 그래서 props.username과 같은 방식으로 호출. 그러면 프롬의 타입을 정의하기 위해서는 type 또는 interface를 사용 가능

1. HelloCompoent.tsx 생성
2. App.tsx의 내용을 App2로 복사하고 초기회3
3. HelloComponent를 App.tsx에 import
4. npm run dev로 빈화면 실행

#### HelloComponent
```tsx
type HelloProps = {
  name: string;
  age: number;
}

function HelloComponent({ name, age } : HelloProps) {  // 객체 구조분해 주목
  return(
    <>
      Hello, {name}, you are {age} years old!
    </>
  )
}

export default HelloComponent
```
이상의 코드를 해석하기 위해 알아야 하는 개념
1. 객체 구조 분해
2. props drilling
3. props가 JS의 객체라는 점
4. typescript상의 매개변수에서 자료형을 통제하는 법

이상의 코드를 적용하면 age='20'과 같은 방식으로 프롭을 전달하게 됬을 때 오류 메세지를 출력. jsx의 경우 오류 메세지 자체가 나타나지 않는다. 그러면 이 오류가 드러나는 시점은 age='20'이라는 string data를 가지고 수학 연산을 시도했을 시점이 되야지 오류 확인 가능

하지만 TS를 사용했을 경우 경고 메세지를 보내주기 때문에 연산 이전에 수정을 할 수 있는 점에서 도입할 가치가 존재

```tsx
import HelloProps from "./types/types"

function HelloComponent({ name, age } : HelloProps) {  // 객체 구조분해 주목
  return(
    <>
      Hello, {name}, you are {age} years old!
    </>
  )
}

export default HelloComponent
```
이상은 이미 정의한 type를 type/types.ts로 분할 import 한 예시로 이상처럼 했을 경우 ByeComponent를 만든다고 가정하면 거기서도 똑같이 HelloProps를 사용 가능

그런데 이 타입추론이라는 개념이 TS에서만 적용되는게 아니라 표준 리액트 탕비인 FC(Function Component)가 존재

```tsx
import React from 'react';
import {HelloProps} from './types/types';

const HelloComponent : React.FC<HelloProps> = ({name, age}) => {
  return (
    <>
      Hello {name}, you are {age} years old!
    </>
  );
}
```

```jsx
// boolean
const [ isReady, setIsReady ] = useState(false);

// string
const [ message, setMessage ] = useStae('');

// number
const [ count, setCount ] = useState(0);
```
이상의 useState 훅을 생각하면 intiialValue값을 타입 추론 한다는걸 알 수 있기에 
```jsx
setCount('Hello');
```
와 같은 방식으로 암시적으로 작성된 type과 다른 자료형을 argument로 넣으면 오류 발생

그런데 TS는 명시적으로 타입을 서정해서 useState()의 initialValue의 자료형을 통제 가능

```tsx
const [ message, setMessage ] = useState<string | undefined>(undefined);
```
이상의 예시는 message의 자료형이 string이거나 undefined로 넣을 수 있다

혹은 type / interface를 사용가능한 방법도 있는데

```ts
// types.ts
type User = {
  id: number;
  name: string;
  email: string;
}
```
```tsx
import {User} from './types/types';
import { useState } from 'react';

function exmapleComponent() {
  // 타입을 상태와 함께 활용하고자 할 때 초기값으로 아무것도 담기지 않은 User 객체를 이용
  // const [ user, setUser ] = useState<User>({} as User)
  // 혹은 null 값도 허용
  const [ user, setUser ] = useState<User>({} as User) 

  return(
    <>

    </>
  )
}

export default ExampleComponent
```

### 이벤트
TS를 이용할 때는 이벤트 타입을 세분화할 필요가 존재하는데

```tsx
<input
  type='text'
  onChange={handleChange}
  value={name}
>
```
과 같이 정의되어 있을 때 handleChange의 예시는 

```tsx
const handleChange = (event) => {
  setName(event.target.value)
}
```
그런데 난해한건, handleSubmit 때도 매개변수를 event로 정했었는데 

event가 특정한 HTML element와 관련이 있다는 점을 명시할때 사용하는 명령어가
```tsx
const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
  setName(event.target.value);
}
```
그러면 form과 관련있는 onSubmit 이벤트 핸들러의 경우
```tsx
const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {
  event.preventDefault();
  alert(`Hello ${name}`);
}
```
와 같은 방식으로 작성. 즉 임의적으로 e 혹은 event로 매개변수 명을 지었지만 어느 HTML 요소와 관련있는지에 따라 딸려있는 속성(특징)과 메서드가 서로 다르기에 TS 상에서는 통제

전체 종류는 [typescript cheat sheets](https://github.com/typescript-cheatsheets/react-typescript-cheatsheet-kr)를 참고