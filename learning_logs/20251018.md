# third party components
awesome-react-components
- https://github.com/brillout/awesome-react-components

1. 컴포넌트들은 README에서 볼 수 있듯 npm을 통해 설치가 가능 
- `npm install component_name@version`
  - ex : `npm install react-date-picker@10.0.3`
- 설치된 컴포넌트를 리액트 앱에서 제거하는 명령어 : `npm uninstall component_name`
  - ex : `npm uninstall react-date-picker`
- 업데이트가 누락된 컴포넌트들 검색 명령어 : `npm outdated`
- 업데이트가 누락된 컴포넌트들 일괄 업데이트 명령어 : `npm update`  
- 모든 프로젝트 의존성을 가져오는 명령어 :  `npm list`

# AG Grid
`npm install ag-grid-community@30.1.0 ag-grid-react@30.1.0`

AG Grid는 리액트 앱을 위한 데이터 그리드 컴포넌트
- 스프레드 시트처럼 데이터 표시에 사용하고 상호작용 가능
- 필터링 / 정렬 / 피벗 기능 등 포함

```tsx
import { useState } from 'react'
import axios from 'axios'
import { AgGridReact } from 'ag-grid-react'
import 'ag-grid-community/styles/ag-grid.css'
import 'ag-grid-community/styles/ag-theme-material.css'
import './App.css' 

type Repository = {
  id: number;
  full_name: string;
  html_url: string;
  username: string;
}

function App() {
  const [ keyword, setKeyword ] = useState('');
  const [ repodata, setRepodata ] = useState<Repository[]>([]);

  const handleClick = () => {
    axios.get<{items : Repository[]}>(`https://api.github.com/search/repositories?q=${keyword}`)
    .then(response => setRepodata(response.data.items))
    .catch(error => console.log(error))
  }

  return (
    <div className='App'>
      <input type="text" onChange={e => setKeyword(e.target.value)} value={keyword}/>
      <button onClick={handleClick}>Search</button>
      <div className='ag-theme-material'
        style={{height: 500, width: 850}}
      >
        <AgGridReact rowData={repodata}/>
      </div>
    </div>
  )
}

export default App
```
```tsx
import { AgGridReact } from 'ag-grid-react'
import 'ag-grid-community/styles/ag-grid.css'
import 'ag-grid-community/styles/ag-theme-material.css'
```
이상의 import 문들은 ag-grid 컴포넌트 자체와 스타일 시트를 가지고 있고 `import 'ag-grid-community/styles/ag-theme-material.css'`는 구글에서 권장하는 material style을 가져온 것. 그러니 사전 정의 스타일을 가지고와 css를 최소화. 그런데 styles/ag-grid.css를 통해 최소한의 커스터마이징을 할 수 있는데 이를 `style={{height: 500, width:850}}`으로 처리

그리고 return문에 AgGridReact 컴포넌트의 추가를 통해 repoData를 가지고 테이블을 작성하는데 rowData라고 사전에 이름 붙여진 속성에 프롭을 전달. rowData는 객체의 배열을 데이터에 넣게 지원

그리고 ag-grid 컴포넌트는 스타일을 정의한 div element로 감싸야 하기에 
```tsx
return (
  <div className='App'>
    <input type="text" onChange={e => setKeyword(e.target.value)} value={keyword}/>
    <button onClick={handleClick}>Search</button>
    <div className='ag-theme-material'
      style={{height: 500, width: 850}}
    >
      <AgGridReact rowData={repodata}/>
    </div>
  </div>
)
```
의 형태의 return문 작성

그 다음 과정으로 ag-grid에 이용될 컬럼을 정의. 컬럼 정의 객체의 배열에 해당하는 columnDefs라는 상태를 정의한 것으로 ag-grid는 이용할 수 있는 ColDef 타입을 제공(TypeScript로 작성하는 이유). 컬럼 객체에서는 필수 field 프롭을 이용해 데이터 접근자를 정의해야 하는데 여기서는 field 값이 컬럼을 표시해야하는 REST API 응답 데이터의 속성 이름

```tsx
  import { useState } from 'react'
import axios from 'axios'
import { AgGridReact } from 'ag-grid-react'
import 'ag-grid-community/styles/ag-grid.css'
import 'ag-grid-community/styles/ag-theme-material.css'
import './App.css' 
import { ColDef, ICellEditorParams } from 'ag-grid-community'

type Repository = {
  id: number;
  full_name: string;
  html_url: string;
  username: string;
}

function App() {
  const [ keyword, setKeyword ] = useState('');
  const [ repodata, setRepodata ] = useState<Repository[]>([]);
  const [ columnDefs ] = useState<ColDef[]>([
    {field: 'id', sortable: true, filter: true},          // 컬럼1
    {field: 'full_name', sortable: true, filter: true},   // 컬럼2
    {field: 'html_url', sortable: true, filter: false},   // 컬럼3
    {
      field: 'full_name',
      cellRenderer: (params: ICellEditorParams) => (
        <button
          onClick={() => alert(params.value)}
        >
          Press Me!
        </button>
      )
    }
  ])

  const handleClick = () => {
    axios.get<{items : Repository[]}>(`https://api.github.com/search/repositories?q=${keyword}`)
    .then(response => setRepodata(response.data.items))
    .catch(error => console.log(error))
  }

  return (
    <div className='App'>
      <input type="text" onChange={e => setKeyword(e.target.value)} value={keyword}/>
      <button onClick={handleClick}>Search</button>
      <div className='ag-theme-material'
        style={{height: 500, width: 850}}
      >
        <AgGridReact 
          rowData={repodata}
          columnDefs={columnDefs}
          pagination={true}
          paginationPageSize={5}
        />
      </div>
    </div>
  )
}

export default App
```

이상에서 컬럼의 정의 및 거기에 딸린 properties를 확인. sortable / filter였고 그 다음 추가 컬럼을 정의했는데 거기에 cellRenderer라는 속성

그리고 pagenation / pagenationPageSize는 `<AgGridReact>` 컴포넌트 내부에 정의되 return문과 colDefs 상태를 둘 다 확인할 필요 존재

cellRenederer 프롭 사용시 테이블 셀의 컨텐츠를 사용자 정의 가능. 해당 예시는 Ag Grid 내의 컬럼에서 버튼 렌더링 예시

cellRenderer 속성의 value는 callback 함수로 구성되 매개변수로 params를 받았고 ICellRenderParams Type으로 작성했고 params.value의 값은 field 속성에 정의된 full_name을 사용. 그래서 버튼을 누를시 full_name이 출력

그런데 컬럼 이름이 너무 field와 동일하게만 되어있는데 column을 확인할시 Id / Full_name / Html_url / Full_name으로 Full_name이 두개인 것을 확인 가능. 이를 수정하기 위해서는 `headerName`속성 이용 가능

# Material UI Component 이용
shoppinglist 프로젝트를 생성
- React -TypeScriot
- App.tsx 초기화
- 코드 설치
  - npm install @mui/material@5.14.8
  - npm install @emotion/react@11.11.1
  - npm install @emotion/style@11.11.0

```tsx
import { Container } from '@mui/material'
import { AppBar, Toolbar, Typography } from '@mui/material'
import './App.css'

function App() {

  return (
    <Container>
      <AppBar position="static">
        <Toolbar>
          <Typography variant='h6'>
            쇼핑 리스트 Shopping List
          </Typography>
        </Toolbar>
      </AppBar>
    </Container>
  )
}

export default App
```

이상의 주의점은 각 컴포넌트가 무슨 역할을 하는지로서 Conatiner는 전체 브라우저 화면을 의미하고 AppBar는 상단, 그리고 ToolBar는 nav 역할. Typography는 글씨 관련 역할

이후 실제 shopping list 기능 관련 부분 작성. MUI를 도입한것이기에 일반적인 html + css + js + react의 형태를 감안

```tsx
import { Button, TextField, Dialog, DialogActions, DialogContent, DialogTitle } from "@mui/material";
import { useState } from "react";

function AddItem(props) {
  const [ open, setOpen ] = useState(false);

  const handleOpen = () => {
    setOpen(true);
  }

  const handleClose = () => {
    setOpen(false);
  }

  return(
    <>

    </>
  );
}
```
App 컴포넌트 내에 AddItem 컴포넌트를 추가. 그런데 todolist의 사례는 input에 button 하나만 존재했고 github api를 가지고 올때도 동일했다. 이제 Modal이라는 개념 추가

폼에 product와 amount라는 두 개의 입력필드와 App 컴포넌트 내에 addItem 함수를 호출하는 버튼 추가. _App 컴포넌트에 있는 addItem 함수를 호출할 수 있으려면 addItem 컴포넌트 렌더링시 프롭으로 전달. 모달 Dialog 컴포넌트 외부에 사용자가 새 쇼핑항목을 입력할 수 있는 모달 폼을 여는 버튼을 추가. 해당 버튼은 컴포넌트가 처음 렌더링 될 때 보이는 유일한 요소에 해당

즉 최초에 open 상태가 false이기에 모달 폼은 보이지 않고 버튼만 보인다

```tsx
import { Button, TextField, Dialog, DialogActions, DialogContent, DialogTitle } from "@mui/material";
import { useState } from "react";
import { Item } from "./App";

function AddItem(props) {
  const [ open, setOpen ] = useState(false);
  const [ item, setItem ] = useState<Item>({
    product: '',
    amount: '',
  });

  const handleOpen = () => {
    setOpen(true);
  }

  const handleClose = () => {
    setOpen(false);
  }

  return(
    <>
      <Button onClick={handleOpen}>
        Add Item
      </Button>
      <Dialog open={open} onClose={handleClose}>
        <DialogTitle>New Item</DialogTitle>
        <DialogContent>
          
        </DialogContent>
        <Button onClick={handleClose}>
          Cancel / 취소
        </Button>
        <Button onClick={addItem}>
          Add / 저장
        </Button>
      </Dialog>
    </>
  );
}

export default AddItem
```
까지 주의해야할 점은 App.tsx에 정의된 type인 Item을 가지고 왔다는 점으로 프로젝트의 사이즈가 매우 작고 보통은 types.ts 파일에 전체 타입들이 정의되어있고 거기서 가지고 온다

그리고 addItem 함수가 App.tsx에 정의되어있지만 AddItem 컴포넌트에서 불러오고 있다. 이 부분에 대해 의문을 가질 수 있는데
1. AddItem 컴포넌트 내에 addItem 함수를 정의 불가
  - App.tsx의 addItem 함수를 확인하면 Item이 추가되고 기존의 items들은 그대로 스프레드 연산자로 받아온다는걸 확인 가능
  - 중요한점은 AddItem 컴포넌트에 하나의 item을 추가한걸 상위로 보낼 방법 X
  - React에서 Data Flow는 상위 -> 하위로 이어지는 Top-Down 방식이기에 즉 AddItem 컴포넌트에서 추가하는 함수를 별개로 만들어봤자 App 컴포넌트로 보낼 수 없기에 결과적으로 App 컴포넌트에서 addItem 함수를 만들고 해당 함수를 호출하는 함수를 AddItem 컴포넌트에 정의 필요
  - React의 기초 원리에서 One-way dat flow에 대해 강조한 이유가 나오는 부분
  - Recoil / ContextAPI 등의 전역 상태 관리를 통해 함수를 전부 전역에 등록해 불러옿기도 가능

```tsx
import { Button, TextField, Dialog, DialogActions, DialogContent, DialogTitle } from "@mui/material";
import { useState } from "react";
import { Item } from "./App";

type AddItemProps = {
  addItem: (item: Item) => void;
}

function AddItem(props: AddItemProps) {
  const [ open, setOpen ] = useState(false);
  const [ item, setItem ] = useState<Item>({
    product: '',
    amount: '',
  });

  const handleOpen = () => {
    setOpen(true);
  }

  const handleClose = () => {
    setOpen(false);
  }

  // App.tsx의 addItem 함수를 호출하고 item 상태를 전달
  const addItem = () => {
    props.addItem(item);
    // TextField에 있는 내용을 지우고  Modal 저장
    setItem({product: '',  amount: ''});
    handleClose();
  }

  return(
    <>
      <Button onClick={handleOpen}>
        Add Item
      </Button>
      <Dialog open={open} onClose={handleClose}>
        <DialogTitle>New Item</DialogTitle>
        <DialogContent>
          <TextField value={item.product} margin="dense"
            onChange={e => setItem({...item, product: e.target.value})}
            label="Product/제품명" fullWidth />
          <TextField value={item.amount} margin="dense"
            onChange={e => setItem({...item, amount: e.target.value})}
            label="Amount/수량" fullWidth />
        </DialogContent>
        <Button onClick={addItem}>
          Add / 저장
        </Button>
        <Button onClick={handleClose}>
          Cancel / 취소
        </Button>
      </Dialog>
    </>
  );
}

export default AddItem
```
현재 버전의 코드에서는 props로 전달하는 함수에 주목. 이를 위해 AddItemProps라는 type을 선언. 마찬가지로 App.tsx 역시 확인
```tsx
import { Container } from '@mui/material'
import { AppBar, Toolbar, Typography } from '@mui/material'
import './App.css'
import { useState } from 'react'
import AddItem from './AddItem'

export type Item = {
  product: string;
  amount: string;
}

function App() {
  const [ items, setItems ] = useState<Item[]>([]);
  const addItem = (item:Item) => {
    setItems([item, ...items]);
  }

  return (
    <Container>
      <AppBar position="static">
        <Toolbar>
          <Typography variant='h6'>
            쇼핑 리스트 Shopping List
          </Typography>
        </Toolbar>
      </AppBar>
      <AddItem addItem={addItem}/>
    </Container>
  )
}

export default App
```

현재까지 작성한것을 기준으로 App.tsx에 있는 items 상태가 업데이트 된다는것을 확인 가능

그런데 그 업데이트된 items가 보이지 않고 있기에 업데이트된 items 결과를 보여주는 return 부분의 코드가 필요

```tsx
import { Container } from '@mui/material'
import { AppBar, Toolbar, Typography } from '@mui/material'
import { List, ListItem, ListItemText } from '@mui/material'
import './App.css'
import { useState } from 'react'
import AddItem from './AddItem'

export type Item = {
  product: string;
  amount: string;
}

function App() {
  const [ items, setItems ] = useState<Item[]>([]);
  const addItem = (item:Item) => {
    setItems([item, ...items]);
  }

  return (
    <Container>
      <AppBar position="static">
        <Toolbar>
          <Typography variant='h6'>
            쇼핑 리스트 Shopping List
          </Typography>
        </Toolbar>
      </AppBar>
      <AddItem addItem={addItem}/>
      <List>
        {
          items.map((item, index) => 
            <ListItem key={index} divider>
              <ListItemText 
                primary={item.product}
                secondary={item.amount}/>
            </ListItem>
          )
        }
      </List>
    </Container>
  )
}

export default App
```
이상에서 확인해야하는 점은 기본적으로 items 상태를 업데이트 하는 부분이 어느 부분에서 작성되어야 하는가. 구조는 현재 `App -> AddItem` 컴포넌트 구조로 구성. 즉 App 컴포넌트에 items 결과값을 표시할거냐 AddItem 컴포넌트에 표시할거냐 1/2확률

심플하게 생각하면 items 상태가 정의된 곳이 App이기에 App에 결과값 표시

List 컴포넌트를 App 컴포넌트 내에서 렌더링했고 현재까지 MUI를 보면 위계가 잡혀있는 상황
~~~
List -> ListItem -> ListItemText

ul -> li
~~~
List 내에서 map() 함수를 활용해 ListItem 컴포넌트를 생성(ul 내부에 map으로 li 생성과 동일). 배열이기에 key 프롭 요구도 동일

그리고 `<ListItem key={index} divider>`를 보면 divider라는 속성이 있는데 각 항목 끝에 구분선을 지니고 ListItemText에서 기본 텍스트로 product를 표시하고 보조 텍스트로 amount를 표시. 각각 primary / secondary로 쓰였는데 MUI에서 자주 쓰이는 속성

또한 button 스타일은 `variant="outlined/text/contained"`로 작성 가능

이상의 MUI 라이브러리 사용시 리액트 앱에서 디자인을 일관적으로 가능하고 프로젝트에서 CSS 고려 필요성이 덜해진다. 하지만 기본값이 정해져 있기에 커스터마이징을 위해 emotion이나 tailwind를 고려










# React Router
React Router란 URL을 기반으로 특정 컴포넌트를 렌더링할지 정의할 수 있는 방식

react-router-dom 라이브러리는 라우팅 구현에 이용되는 컴포넌트들 제공
1. BrowserRouter : 웹 기반 애플리케이션을 위한 라우터
2. Route : 주어진 위치가 일치하면 정의된 컴포넌트 렌더링

element 속성은 사용자가 path 프롭에 정의된 contact 엔드포인트로 이동시 렌더링되는 컴포넌트를 정의. 경로는 현재 위치를 기준으로 상대 경로 작성

`<Route path="contact" element={<Contact />}`

혹은 이하처럼 path 속성 끝에 * 와일드 카드 사용 가능

`<Route path="contact"* element={<Contact />}`

contact/mike 혹은 contact/1 등의 엔드포인트들에 전부 Contact 컴포넌트가 렌더링. 또한 Route 컴포넌트는 여러 Route 컴포넌트를 감싸는게 가능해 이를 위해서는 Link 컴포넌트는 애플리케이션에 대한 탐색 기능을 제공

`<Link to="/contact">Contact</Link>`

```tsx
// App
import { BrowserRouter, Routes, Route, Link  } from 'react-router-dom'
import Home from './Home'
import Contact from './Contact'
import './App.css'
import PageNotFound from './PageNotFound'
import ContactSeoul from './ContactSeoul'
import ContactBusan from './ContactBusan'

function App() {

  return (
    <>
      <BrowserRouter>
        <nav>
          <Link to="/">Home</Link>{' | '}
          <Link to="/contact">Contact</Link>
        </nav>
        <Routes>
          <Route path='/' element={<Home />} />
          <Route path='contact' element={<Contact />} >
            <Route path='seoul' element={<ContactSeoul />} />
            <Route path='busan' element={<ContactBusan />} />
          </Route>
          <Route path='*' element={<PageNotFound />} />
        </Routes>
      </BrowserRouter>
    </>
  )
}

export default App

// Contact
import { Link, Outlet } from "react-router-dom"

function Contact() {
  return(
    <>
      <h3>Contact Us</h3>
      <nav>
        <Link to="seoul">서울 지점</Link> {' | '}
        <Link to="busan">부산 지점</Link>
      </nav>
      <hr />
      <Outlet />
    </>
  )
}

export default Contact
```
`<Outlet />` : 중첩 라우트(Nested Routes)를 렌더링하기 위해 사용하는 자리 표시자(placeholder)

그러니 Outlet 컴포넌트가 있는 장소에 해당 자식 컴포넌트를 불러라 라는 의미로서 현 코드처럼 App.tsx의 `<Route path='contact' element={<Contact />} >`의 내부에 seoul과 busan 엔드포인트를 지정했고 거기에 ContactSeoul과 ContactBusan을 이미 명시. 그렇기에 Contact 컴포넌트 내에서 다시 ContactSeoul 및 ContactBusan을 명시가 아니라 `<Outlet />` 컴포넌트로 부르는 것

이상의 라이브러리 사용시 컴포넌트들이 하나의 URL(ex: localhost:5173)만 가지는게 아닌 각각의 다른 URL을 가지게 통제해 필요한 부분만 렌더링 가능

# 요약
1. 3rd party 컴포넌트 학습
  - react-date-picker
  - AgGrid
    - 테이블을 대체하는 컴포넌트
      - filter, sort, column 정의와 관련된 부분 학습
  - MUI 컴포넌트
    - 이상에서 중요한것은 각각의 HTML 태그에 해당하는 컴포넌트들 존재
      - `<input>` 태그를 대체하는건 `<TextField>`인 등 내부에 MUI 자체 property 존재
      - CSS보다 사용하기 용이
  - react-router-dom
    - SPA 상에서 하나의 URL이 아닌 다수의 URL을 다루는 방식
    - 조건부 렌더링이 if문이나 삼항연산자를 쓰는것 뿐 아니라 내부의 URL을 기준으로 서로 다른 컴포넌틀를 렌더링 하는 방식

외부 라이브러리를 다루는 현 시점에서는 공식 문서의 활용이 중요

#  Full Stack 개발 - 스프링부트 REST API 웹 서비스를 위한 프론트엔드
## UI prototype
1. 데이터베이스의 자동차를 테이블에 나열하고 페이징, sorting, filtering 기능을 구현 - AG Grid 사용
2. 데이터베이스에 새 차량을 추가 가능한 모달 폼을 여는 버튼 구현 - MUI
3. 차량 테이블의 각 행에 자동차를 편집하거나 데이터베이스에서 삭제하는 버튼 구현 - AG Grid를 이용해 거기에 버튼을 클릭했을때 특정 함수가 호출되고 그게 백엔드로 전달 -> DB로 들어가 PUT 혹은 DELETE 메서드 실행
4. CSV 파일로 변형해 다운 받는 링크 혹은 버튼 구현

## FrontEnd React 프로젝트 생성
carfront project 생성 React / TypeScript
- npm install
- npm install @emotion/react@11.14.0
- npm install @emotion/styled@11.14.0
- npm install @mui/material@5.17.1
- npm install @tanstack/react-query@4.36.1
- npm install axios@1.9.0
- App.tsx 초기회
- npm run dev / git push
