## 환경 변수 이용
서버 URL은 CRUD 기능을 만들 때 소스 코드에서 여러 번 반복될 수 있으며 백엔드가 배포시 localhost:8080이 아니니기에 환경변수로 미리 정의 필요. 예시로 수정이 이루어지면 갱신된 getCars()가 다시 요청되어야하기에 수정 부분의 localhost:8080과 다시 getCars()를 요처할 때의 localhost:8080을 매번 URL로 전부 고치는건 비효율적

그래서 환경변수에 URL을 저장하면 URL이 바뀔 때 환경 변수만 수정하면 일괄변환이 될것이기에 환경 변수 설정을 미리하고 실행

vite project 상에서 환경 변수 이름은 `VITE_`로 시작하고 접두사가 VITE_인 변수만 소스 코드에서 접근 가능

1. 앱 루트 폴더에 `.env` 파일 생성

`VITE_API_URL=http://localhost:8080`

2. src 폴더에 api 폴더 -> carapi.ts 생성
- 이상은 모든 API 호출 함수를 자체 모듈로 분리하는 과정. 즉 현재 상황은 getCars()를 Carlist 컴포넌트에서 분리한다는 의미
- .env 파일이 src 내부에 있으면 안되고 최상위 폴더에 위치

```tsx
// carapi.ts
import axios from "axios";
import { CarResponse } from "../types";

export const getCars = async (): Promise<CarResponse[]> => {
    const response = await axios.get(`${import.meta.env.VITE_API_URL}/api/cars`);

    return response.data._embedded.cars;
}



// .env
VITE_API_URL=http://localhost:8080
```

# 페이징 / 필터링 / 정렬 추가
- MUI 기준으로 작성
- 터미널에서 npm install @mui/x-data-grid@8.4.0

```tsx
import { CarResponse } from "../types"
import { useQuery } from "@tanstack/react-query";
import { getCars } from "../api/carapi";
import { DataGrid, GridColDef } from "@mui/x-data-grid";

function Carlist() {
  
  const {data, error, isSuccess} = useQuery({
    queryKey: ["cars"],
    queryFn: getCars
  });

  const columns: GridColDef[] = [
    {field: 'brand', headerName: 'Brand', width: 200},
    {field: 'model', headerName: 'Model', width: 200},
    {field: 'color', headerName: 'Color', width: 200},
    {field: 'registrationNumber', headerName: 'Reg.num', width: 150},
    {field: 'modelYear', headerName: 'ModelYear', width: 150},
    {field: 'price', headerName: 'Price', width: 150}
  ];

  if(!isSuccess) {
    return <span>Loading...</span>
  }

  if (error) {
    return <span>자동차를 불러오는데 실패했습니다.</span>
  }
  else {
    return (
      <DataGrid
        rows={data}
        columns={columns}
        getRowId={row => row._links.self.href}
      />
    )
  }
}
export default Carlist
```
# 삭제 기능 추가
- 삭제의 중요한 점은 특정 row를 선택해야한다는 것과 엔드포인트에 `{id}`가 추가되야한다

- 그런데 각 row에 대한 href를 가지고 있다는 점을 주목

```json
{
  "brand": "Kia",
  "model": "Seltos",
  "color": "Chacol",
  "registrationNumber": "370SU5690",
  "modelYear": 2020,
  "price": 30000000,
  "_links": {
      "self": {
          "href": "http://localhost:8080/api/cars/1"
      },
      "car": {
          "href": "http://localhost:8080/api/cars/1"
      },
      "owner": {
          "href": "http://localhost:8080/api/cars/1/owner"
      }
  }
}
```
HATEOAS를 적용해서 각각의 id값이 자동 설정되어있는데 DELETE method를 _links.self.href로 보내면 자동 삭제

그래서 현재 GET 요청으로 `import.meta.env.VITE_API_URL/api/cars`를 하게 되면 x-data-grid에 의해 각 자동차 row들이 나오고 x-data-grid의 GridColDef를 수정해 버튼을 추가해 삭제 기능 적용. 이미 key 속성에 _link.self.href 값이 존재

GridColDef에 딸린 columns 상수를 수정해 하나의 column을 추가. 여기에 Delete 버튼을 할당. 다른 컬럼들과 달리 세세한 커스텀이 필요해서 renderCell 컬럼 속성을 사용해 셀의 컨텐츠가 렌더링되는 방식을 정의(현재는 button 태그)

그리고 현 상황에서는 alert를 통해 _links.self.href를 불러오는지 확인했는데 중요한 개념은 onClick={alert(_links.self.href)}를 쓰면 애초에 함수의 결과값이 출력되기에 버튼을 누르는것과 무관

onClick={() => alert(_links.self.href)}과의 차이점 인지 필용

함수의 이름을 이벤트 핸들러에 전달 / 함수의 결과를 이벤트 핸들러에 전달하는 것의 차이점 복스 필요 및 매개변수가 존재하는 함수의 이름만 전달하는 방식 고려

button 태그 내에 sort / filter를 비활성화시키고 컬럼의 메뉴를 비활성화시키는 disableColumnMenu를 true로 설정. 그리고 onClick 이벤트 설정. 다음 과정으로 각 row들마다 href가 존재하기에 delete 요청을 전송 가능

현재까지의 코드는 cardatabase_2를 기준으로 back-front 연결을 하는건 맞지만 Spring Data REST를 기반으로 하고 있어서 로직 설명 안됨

즉 코드를 보고 로직을 떠올릴려면 cardatabase_5의 CarController와 CarService 확인 필요

Axios의 delete 메서드를 이용해 DELETE 요청을 보내는데 DELETE 요청은 id 값이 필요하다는걸 CarService에서 확인 가능. id 값은 href에 위치

```tsx
import axios from "axios";
import { CarResponse } from "../types";

export const getCars = async (): Promise<CarResponse[]> => {
    const response = await axios.get(`${import.meta.env.VITE_API_URL}/api/cars`);

    return response.data._embedded.cars;
}

export const deleteCar = async (link: string) : Promise<CarResponse> => {
    const response = await axios.delete(link);
    return response.data
}
```

그리고 함수들을 frontend에서 다 분리를 했는데 그러면 deleteCar 함수를 작성하는 파일은 getCars()의 return 타입과 deleteCar()의 return 타입의 차이를 감안. getCars()는 자동차들의 정보를 담고있는 배열만 가지고와서 그것이 Carlist 컴포넌트의 return에 표기하면 되는 반면 삭제 후에는 GET 요청 이후의 완전한 json이 return될 필요가 있기에 그 차이로 인해서 ._embedded 유무가 결정

현재 deleteCar() 메서드를 호출하기 위해 useMutation() hook을 적용. 그리고 삭제 버튼을 누르면 삭제가 DB에서는 됬지만 frontend상에서는 새로고침을 해야 이루어진다

그러면 onSuccess는 삭제 이후 새로 프론트엔드에 갱신된 cars 정보를 가지고 오기에 자동차가 삭제되면 프론트엔드 자동 새로고침 필요. react qurery에소 가져온 데이터는 쿼리 클라이언트가 처리하는 캐시에 저장되니 쿼리 클라이언트에는 데이터를 다시 가져오는데 이용가능한 쿼리 무효화 기능 존재

useEffect()에서 콜백함수로 getCars()를 호출하는데 `[cars]`로 cars의 상태가 변할때마다 재렌더링 일으키는 방법도 존재. 그런데 현재 작성 방식은 useState를 쓰지 않고 useQuery로 getCars를 불러오기에 cache에 cars 데이터가 저장되있을거란 점을 이용해 코드를 작성

쿼리 무효화 기능을 적용하기 위해 먼저 현재의 쿼리 클라이언트를 반환하는 useQueryClient 훅 함수를 가져온다

```tsx
// Carlist.tsx
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { getCars, deleteCar } from "../api/carapi";
import { DataGrid, GridColDef, GridCellParams } from "@mui/x-data-grid";

function Carlist() {
  const queryClient =  useQueryClient();
  const {data, error, isSuccess} = useQuery({
    queryKey: ["cars"],
    queryFn: getCars
  });
```

## 토스트 메세지 표시
이상에서 구현한 부분은 삭제를 했을 때 cache를 확인해 최신 정보를 가지고 오는 방식을 택했고 하지만 1번 id를 가지는 것을 삭제했을때는 위에 없어진게 보이지만 20개 중 12번을 삭제하면 렌더링시 다시 1번부터 나와 체크하기 어려움

UX 개선을 위해 삭제가 되었다고 표시하되 alert가 아닌 다른 방식 사용

### SnackBar
- 주목할 부분은 shoppinglist 앱에서 도입한 Modal과 유사한 성질을 지니고 있다는것. 그래서 동일하게 `const [open, setOpen] = useState(false);`

- 그러면 특정상황이 발생한다면 setOpen(true)를 통해 메세지를 출력하고 다시 setOpen(false);로 메세지를 삭제

shoppinglist에서는 add item을 누르면 open이 true로 바뀌어 modal창이 렌더링. 그러면 삭제 후에 삭제되었다고 메세지를 띄우고 싶으면 Carlist에서 어느 부분에 `setOpen(true);`를 할지 고려

```tsx
function Carlist() {
  const [ open, setOpen ] = useState(false);
  const queryClient =  useQueryClient();
  const {data, error, isSuccess} = useQuery({
    queryKey: ["cars"],
    queryFn: getCars
  });

  const { mutate } = useMutation(deleteCar, {
    onSuccess: () => {
      setOpen(true);
      queryClient.invalidateQueries({ queryKey: ["cars"]});   // 이 부분은 useQuery()를 정의한 부분과 연관
    },
    onError: err => {
      console.log(err);
    }
  })

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
<>
  <DataGrid
    rows={data}
    columns={columns}
    getRowId={row => row._links.self.href}
  />
  <Snackbar
    open={open}
    autoHideDuration={2000}
    onClose={() => setOpen(false)}
    message='선택한 자동차 정보가 삭제되었습니다'
  />
</>
```

### confirm 상자 추가
button 태그 수정

```tsx
// carlist.tsx
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { getCars, deleteCar } from "../api/carapi";
import { DataGrid, GridColDef, GridCellParams } from "@mui/x-data-grid";
import { Snackbar } from "@mui/material";
import { useState } from "react";

function Carlist() {
  const [ open, setOpen ] = useState(false);
  const queryClient =  useQueryClient();
  const {data, error, isSuccess} = useQuery({
    queryKey: ["cars"],
    queryFn: getCars
  });

  const { mutate } = useMutation(deleteCar, {
    onSuccess: () => {
      setOpen(true);
      queryClient.invalidateQueries({ queryKey: ["cars"]});
    },
    onError: err => {
      console.log(err);
    }
  })

  const columns: GridColDef[] = [
    {field: 'brand', headerName: 'Brand', width: 200},
    {field: 'model', headerName: 'Model', width: 200},
    {field: 'color', headerName: 'Color', width: 200},
    {field: 'registrationNumber', headerName: 'Reg.num', width: 150},
    {field: 'modelYear', headerName: 'ModelYear', width: 150},
    {field: 'price', headerName: 'Price', width: 150},
    {
      field: 'delete',
      headerName: 'Delete',
      width: 90,
      sortable: false,
      filterable: false,
      disableColumnMenu: true,
      renderCell: (params: GridCellParams) => (
        <button 
          onClick={() => {
            if (window.confirm(`${params.row.brand}의 ${params.row.model} 자동차를 삭제하시겠습니까?`)) 
            mutate(params.row._links.self.href)}}
        >
          Delete
        </button>
      )
    }
  ];

  if(!isSuccess) {
    return <span>Loading...</span>
  }

  if (error) {
    return <span>자동차를 불러오는데 실패했습니다.</span>
  }
  else {
    return (
      <>
        <DataGrid
          rows={data}
          columns={columns}
          getRowId={row => row._links.self.href}
        />
        <Snackbar
          open={open}
          autoHideDuration={2000}
          onClose={() => setOpen(false)}
          message='선택한 자동차 정보가 삭제되었습니다'
        />
      </>
    )
  }
}

export default Carlist
```

# 생성 기능 추가
MUI 모달 폼을 이용해 Car row를 추가할 수 있게 수정. New Car라는 버튼을 추가해 버튼을 누르면 모달 폼이 열리게. 그러면 모달 폼 내에서는 여러개의 input이 있어 entity 상의 final/@Nonnull이 있는 field에 대한 모든 입력을 바도 이를 저장하거나 취소 가능한 버튼을 내부에 구현

shopping list에서 add item 버튼과 그 내부 모달 폼 형식을 참조

```tsx
import { Dialog, DialogActions, DialogContent, DialogTitle } from "@mui/material";
import { Car } from "../types";
import { useState } from "react";

function AddCar() {
  const [ open, setOpen ] = useState(false);
  const [ car, setCar ] = useState({
    brand: '',
    model: '',
    color: '',
    registrationNumber: '',
    modelYear: 0,
    price: 0
  });

  const handleClickOpen = () => setOpen(true);

  const handleClickClose = () => setOpen(false);

  const handleChange = (event: ChangeEvent<HTMLInputElement>) => {
    setCar({...car, [event.target.name]: event.target.value});
  }

  return(
    <>
      <button onClick={handleClickOpen}>New Car</button>
      <Dialog open={open}>
        <DialogTitle>New Car</DialogTitle>
        <DialogContent>
          <input type="text" name="brand" value={car.brand} placeholder="Brand" onChange={handleChange}/><br />
          <input type="text" name="model" value={car.model} placeholder="Model" onChange={handleChange}/><br />
          <input type="text" name="color" value={car.color} placeholder="Color" onChange={handleChange}/><br />
          <input type="text" name="registrationNumber" value={car.registrationNumber} placeholder="Number" onChange={handleChange}/><br />
          <input type="text" name="modelYear" value={car.modelYear} placeholder="Year" onChange={handleChange}/><br />
          <input type="text" name="price" value={car.price} placeholder="Price" onChange={handleChange}/><br />
        </DialogContent>
        <DialogActions>
          <button onClick={handleClickOpen}>Save | 저장</button>
          <button onClick={handleClickClose}>Cancel | 취소</button>
        </DialogActions>
      </Dialog>
    </>
  );
}

export default AddCar
```
추후 html 태그를 mui로 변환할 필요 존재. 현재로서는 브라우저 상의 화면은 구현된 상태. 이후에는 axios.post를 통해 db로 데이터값을 넘겨 저장시키고 완료시 갱신된 getCars()를 구현 필요. 또한 저장/취소가 된 이후 input창이 초기화하는걸 고려(수정때는 초기화된 input이 아닌 기존 값들 요구)

```tsx
// AddCar.tsx
import { Dialog, DialogActions, DialogContent, DialogTitle } from "@mui/material";
import { Car } from "../types";
import { useState } from "react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { addCar } from "../api/carapi";

function AddCar() {
  const [ open, setOpen ] = useState(false);
  const [ car, setCar ] = useState({
    brand: '',
    model: '',
    color: '',
    registrationNumber: '',
    modelYear: 0,
    price: 0
  });

  const handleClickOpen = () => setOpen(true);

  const handleClickClose = () => setOpen(false);

  const handleChange = (event: ChangeEvent<HTMLInputElement>) => {
    setCar({...car, [event.target.name]: event.target.value});
  }

  const queryClient = useQueryClient();

  const { mutate } = useMutation(addCar, {
    onSuccess: () => {
      queryClient.invalidateQueries(["cars"]);
    },
    onError: err => {
      console.log(err);
    },
  });

  const handleSave = () => {
    mutate(car);
    setCar({
      brand: '',
      model: '',
      color: '',
      registrationNumber: '',
      modelYear: 0,
      price: 0
    });
    handleClickClose();
  }

  return(
    <>
      <button onClick={handleClickOpen}>New Car</button>
      <Dialog open={open}>
        <DialogTitle>New Car</DialogTitle>
        <DialogContent>
          <input type="text" name="brand" value={car.brand} placeholder="Brand" onChange={handleChange}/><br />
          <input type="text" name="model" value={car.model} placeholder="Model" onChange={handleChange}/><br />
          <input type="text" name="color" value={car.color} placeholder="Color" onChange={handleChange}/><br />
          <input type="text" name="registrationNumber" value={car.registrationNumber} placeholder="Number" onChange={handleChange}/><br />
          <input type="text" name="modelYear" value={car.modelYear} placeholder="Year" onChange={handleChange}/><br />
          <input type="text" name="price" value={car.price} placeholder="Price" onChange={handleChange}/><br />
        </DialogContent>
        <DialogActions>
          <button onClick={handleSave}>Save | 저장</button>
          <button onClick={handleClickClose}>Cancel | 취소</button>
        </DialogActions>
      </Dialog>
    </>
  );
}

export default AddCar



// type.ts
export type CarResponse = {
  brand: string;
  model: string;
  color: string;
  registrationNumber: string;
  modelYear: number;
  price: number;
  _links: {
    self: {
      href: string;
    }, 
    car: {
      href: string;
    }, 
    owner: {
      href: string;
    }
  }
}

export type Car = {
  brand: string;
  model: string;
  color: string;
  registrationNumber: string;
  modelYear: number;
  price: number;
}



// carapi.ts
import axios from "axios";
import { CarResponse, Car } from "../types";

export const getCars = async (): Promise<CarResponse[]> => {
    const response = await axios.get(`${import.meta.env.VITE_API_URL}/api/cars`);

    return response.data._embedded.cars;
}

export const deleteCar = async (link: string) : Promise<CarResponse> => {
    const response = await axios.delete(link);
    return response.data
}

export const addCar = async(car: Car) : Promise<CarResponse> => {
    const response = await axios.post(`${import.meta.env.VITE_API_URL}/api/cars`, car, {
        headers: {
            'Content-Type': 'application/json',
        },
    });

    return response.data;
}
```

# useMutation

```jsx
import { useMutation } from "@tanstack/react-query";
// useMutation이 return 하는 객체에는 이 세가지 말고도 여러 속성값 존재.
const { data, isLoading, mutate } = useMutation(mutationFn, options);
```

useQuery가 GET 요청으로 데이터를 불러 오는데 사용된다면 useMutation은 React Query를 이용해 서버에 데이터 변경 작업을 요청할 때 사용. `isLoading`과 `data`는 useQuery와 같이 완료 여부와 데이터를 반환하지만 `mutate`은 mutationFn으로 제공된 함수를 작동시키는 트리거 함수

#### useMutation에 들어가는 인자 값

1. `mutationFn`:  데이터를 수정하고 업데이트하고 삭제하는데 사용할 함수로 fetch나 axios를 사용하여 promise를 반환하는 함수가 와야함
2. `options`:  useMutation에도 많은 옵션이 있지만 많이 쓰는 4가지 옵션
    - `onMutate`: Promise 객체를 반환하는 Callback 함수로써 mutation 함수가 실행되기 전에 실행되고 mutation 함수와 동일한 변수가 제공
    - `onError`: mutation이 실패한 경우 실행할 Callback 함수
    - `onSettled`:  mutation이 실패 또는 성공 여부에 관계 없이 실행할 Callback 함수
    - `onSuccess`: mutation이 성공한 경우 실행할 Callback 함수

#### 사용예시

```jsx
// app.jsx
// getPosts 함수는 게시물 목록을 가져오는 함수
export const getPosts = async () => {
  const { data }= await axios.get("http://localhost:8080/post");
  return data;
};

// createPost 함수는 게시물을 생성하는 함수
export const createPost = async (title, content) => {
	await axios.post("http://localhost:8080/post", {
      title,
      content,
    });
};

import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { getPosts, createPost } from "./api.js"

export default function App() {
	const queryClient = useQueryClient();
	const { isLoading, data: posts } = useQuery("posts", getPosts);
	const createMutate = useMutation(
	    ({ title, content }) => {
	      createPost(title, content);
	    },
	    {
	      onSuccess: () => {  // 비동기 통신이 성공적으로 이루어 졌을때 posts 라는 queryKey를 찾아 데이터를 새로 받아온다
	        queryClient.invalidateQueries("posts"); 
	      },
	    }
	  );

	const handleSubmit = async (e) => {
    e.preventDefault();
    const { title, content } = e.target;
		
		// 위에서 선언한 createMutate의 mutate함수를 사용하여 createPost 함수를 실행
    createMutate.mutate({ title: title.value, content: content.value });
  };

  return (
    <div>
			<form onSubmit={handleSubmit}>
			{...중략}
			</form>
      {isLoading
        ? "LOADING..."
        : posts.map((post, index) => <div>{`${index}) ${post.title}`}</div>)}
    </div>
  );
}
```

useMutation를 사용해 생성, 업데이트, 삭제 등의 처리 할 수 있고, queryClient가 검색할 수 있는 Query key라면 queryClient.invalidateQueries(queryKey)를 통해 데이터를 손쉽게 갱신 가능